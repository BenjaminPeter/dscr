<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>One sample location estimation; DSCR example</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{A Vignette to illustrate dscr}
-->

<h1>One sample location estimation; DSCR example</h1>

<p>This vignette is designed to illustrate the (in development) dscr package for Dynamic Statistical Comparisons in R.</p>

<p>We&#39;ll do a simulation study to assess methods for estimating the mean of a distribution. 
The simulations will be performed under 
three scenarios: a normal distribution, a uniform distribution
and a Cauchy (t distribution on 1df). And we&#39;ll compare three methods: 
sample mean, sample median and the Winsorized mean (from the psych package). </p>

<p>First load the library.</p>

<pre><code class="r">library(dscr)
#  install_github(repo=&quot;stephens999/dscr&quot;)
</code></pre>

<p>Now define the function to create data, which consists of input, and meta-data. 
The input is what the methods will be given. The meta data will be used
when scoring the methods. So here, the input is a random sample, and the meta-data is the true mean (0). </p>

<p>This function must take a first parameter seed (which is the seed of the pseudo-random number generator, set before any data are generated). Additional arguments can be passed through a second parameter, args, which is a list. In this case we use args to pass number of samples and the type distribution to be simulated from.</p>

<pre><code class="r">datamaker = function(seed,args){

  set.seed(seed)

  nsamp=args$nsamp
  disttype=args$disttype

  #here is the meat of the function that needs to be defined for each dsc to be done
  if(disttype==&quot;normal&quot;){
    input = list(x=rnorm(nsamp,0,1))
    meta =  list(truemean=0)
  }

  if(disttype==&quot;uniform&quot;){
    input = list(x=runif(nsamp,-1,1))
    meta = list(truemean=0)
  }

  if(disttype==&quot;Cauchy&quot;){
    input = list(x=rt(nsamp,df=1))
    meta = list(truemean=0)
  }
  #end of meat of function

  data = list(meta=meta,input=input)

  return(data)
}
</code></pre>

<p>Now define the scenarios that use this datamaker. Each scenario is determined by the datamaker,
its arguments, and the seeds it uses. (Maybe the list of seeds should not be part of the scenario definition - I&#39;m not sure). Each scenario also has a name which is used for naming the scenario in results and also output directories - so use something that is a valid filename. </p>

<pre><code class="r">scenarios=list()
scenarios[[1]]=list(name=&quot;normal&quot;,fn=datamaker,args=list(disttype=&quot;normal&quot;,nsamp=1000),seed=1:100)
scenarios[[2]]=list(name=&quot;uniform&quot;,fn=datamaker,args=list(disttype=&quot;uniform&quot;,nsamp=1000),seed=1:100)
scenarios[[3]]=list(name=&quot;Cauchy&quot;,fn=datamaker,args=list(disttype=&quot;Cauchy&quot;,nsamp=1000),seed=1:100)
</code></pre>

<p>Now define the methods.
They have to have the form where they take &ldquo;input&rdquo; and produce &ldquo;output&rdquo;
in a specified format. In this case the input format is a list with one component (x).
The output format is a list with one component (meanest), the estimated mean. </p>

<p>Effectively we have to write a &ldquo;wrapper&rdquo; function for each of our three methods
that makes sure that they conform to this input-output requirement. (Note that the
winsor.wrapper function makes use of the function winsor.mean from the psych package.)
Note that we allow for additional arguments ot each function, but don&#39;t use them here.</p>

<pre><code class="r">library(psych)

mean.wrapper = function(input,args){
  return(list(meanest = mean(input$x)))  
}

median.wrapper = function(input,args){
  return(list(meanest = median(input$x)))    
}

winsor.wrapper = function(input,args){
  return(list(meanest = winsor.mean(input$x,trim=0.2)))
}
</code></pre>

<p>Now define a list of the methods we&#39;ll use. 
Each method is defined by its name, the function used to implement it, and any additional arguments (none here):</p>

<pre><code class="r">  methods=list()
  methods[[1]] = list(name=&quot;mean&quot;,fn =mean.wrapper,args=NULL)
  methods[[2]] = list(name=&quot;median&quot;,fn=median.wrapper,args=NULL)
  methods[[3]] = list(name=&quot;winsor&quot;,fn=winsor.wrapper,args=NULL)
</code></pre>

<p>And define a score function that says how well a method has done. Here we&#39;ll use squared error
and absolute error:</p>

<pre><code class="r">score = function(data, output){
  return(list(squared_error = (data$meta$truemean-output$meanest)^2, abs_error = abs(data$meta$truemean-output$meanest)))
}
</code></pre>

<p>Now we&#39;ll run all the methods on all the scenarios:</p>

<pre><code class="r">  library(dscr)
  res=run_dsc(scenarios,methods,score)
</code></pre>

<p>This returns a dataframe with the results of running all the methods on all the scenarios:</p>

<pre><code class="r">  head(res)
</code></pre>

<pre><code>##   seed scenario method squared_error   abs_error
## 1    1   normal   mean  1.356792e-04 0.011648142
## 2    2   normal   mean  3.843843e-03 0.061998736
## 3    3   normal   mean  4.091567e-05 0.006396535
## 4    4   normal   mean  1.185285e-03 0.034427966
## 5    5   normal   mean  3.027412e-04 0.017399459
## 6    6   normal   mean  6.387521e-04 0.025273546
</code></pre>

<p>And we can summarize the results (eg mean squared error) using the aggregate function</p>

<pre><code class="r">  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##   method scenario  abs_error
## 1   mean   normal 0.02723692
## 2 median   normal 0.03276252
## 3 winsor   normal 0.02801455
## 4   mean  uniform 0.01434410
## 5 median  uniform 0.02357357
## 6 winsor  uniform 0.01739025
## 7   mean   Cauchy 1.57503809
## 8 median   Cauchy 0.04001257
## 9 winsor   Cauchy 0.05056598
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##   method scenario squared_error
## 1   mean   normal  1.128859e-03
## 2 median   normal  1.609965e-03
## 3 winsor   normal  1.213718e-03
## 4   mean  uniform  2.922071e-04
## 5 median  uniform  7.871420e-04
## 6 winsor  uniform  4.371870e-04
## 7   mean   Cauchy  1.082254e+01
## 8 median   Cauchy  2.752190e-03
## 9 winsor   Cauchy  4.545666e-03
</code></pre>

<p>Now suppose we are coming in and want to add a method, say the trimmed mean, to the comparison.
Suppose also we want to try out the trimmed mean with two different settings of the trim argument. 
Here is what we do (note that the different settings of the argument are treated as different methods, but the two methods use the same fn)</p>

<pre><code class="r">  trimmedmean.wrapper = function(input,args){
    return(list(meanest=mean(input$x,trim=args$trim)))
  }

  methods[[4]] = list(name=&quot;trimmedmean1&quot;,fn = trimmedmean.wrapper,args=list(trim=0.2))
  methods[[5]] = list(name=&quot;trimmedmean2&quot;,fn = trimmedmean.wrapper,args=list(trim=0.4))

  res=run_dsc(scenarios, methods, score)
  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##          method scenario  abs_error
## 1          mean   normal 0.02723692
## 2        median   normal 0.03276252
## 3        winsor   normal 0.02801455
## 4  trimmedmean1   normal 0.02847477
## 5  trimmedmean2   normal 0.02944465
## 6          mean  uniform 0.01434410
## 7        median  uniform 0.02357357
## 8        winsor  uniform 0.01739025
## 9  trimmedmean1  uniform 0.01922955
## 10 trimmedmean2  uniform 0.02201650
## 11         mean   Cauchy 1.57503809
## 12       median   Cauchy 0.04001257
## 13       winsor   Cauchy 0.05056598
## 14 trimmedmean1   Cauchy 0.04126206
## 15 trimmedmean2   Cauchy 0.03925086
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##          method scenario squared_error
## 1          mean   normal  1.128859e-03
## 2        median   normal  1.609965e-03
## 3        winsor   normal  1.213718e-03
## 4  trimmedmean1   normal  1.230613e-03
## 5  trimmedmean2   normal  1.339422e-03
## 6          mean  uniform  2.922071e-04
## 7        median  uniform  7.871420e-04
## 8        winsor  uniform  4.371870e-04
## 9  trimmedmean1  uniform  5.299378e-04
## 10 trimmedmean2  uniform  7.128600e-04
## 11         mean   Cauchy  1.082254e+01
## 12       median   Cauchy  2.752190e-03
## 13       winsor   Cauchy  4.545666e-03
## 14 trimmedmean1   Cauchy  3.041337e-03
## 15 trimmedmean2   Cauchy  2.570032e-03
</code></pre>

<p>Note that at present run_dsc does not recreate any files that are already there.
Thus in this case it is only running the new methods (trimmedmean1 and trimmedmean2)- the results for
other methods are already there. If you want to force it to recreate the files then you need
to delete them manually before running run_dsc.</p>

<p>I&#39;m still wondering about how to deal with this best.
I will note that it is possible within run_dsc to specify to run the dsc on only a subset of the methods and scenarios</p>

<pre><code class="r">  res = run_dsc(scenarios, methods, score, c(&quot;Cauchy&quot;,&quot;normal&quot;),c(&quot;trimmedmean1&quot;))
  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##         method scenario  abs_error
## 1 trimmedmean1   normal 0.02847477
## 2 trimmedmean1   Cauchy 0.04126206
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##         method scenario squared_error
## 1 trimmedmean1   normal   0.001230613
## 2 trimmedmean1   Cauchy   0.003041337
</code></pre>

</body>

</html>
